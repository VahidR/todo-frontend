/**
 * Todo API Client
 * ===============
 *
 * This module provides a type-safe API client for communicating with the
 * Todo backend service. It handles all HTTP requests, response parsing,
 * and error handling for todo CRUD operations.
 *
 * Architecture:
 * - Uses the native Fetch API for HTTP requests
 * - Implements a centralized response handler for consistent error handling
 * - Exports typed functions for each API operation
 * - Supports environment-based API URL configuration
 *
 * Backend API Endpoints (RESTful):
 * - GET    /api/todos      - Fetch all todos
 * - POST   /api/todos      - Create a new todo
 * - PUT    /api/todos/:id  - Update an existing todo
 * - DELETE /api/todos/:id  - Delete a todo
 *
 * @module api
 * @author Todo Team
 */

/**
 * Todo Interface
 * --------------
 * Represents the structure of a todo item as returned by the API.
 * This interface should match the backend's todo model exactly.
 *
 * @interface Todo
 * @property {number} id - Unique identifier for the todo (auto-generated by backend)
 * @property {string} title - The text content/title of the todo
 * @property {boolean} completed - Whether the todo has been completed
 * @property {string} created_at - ISO 8601 timestamp of when the todo was created
 * @property {string} updated_at - ISO 8601 timestamp of the last update
 */
export interface Todo {
  id: number;
  title: string;
  completed: boolean;
  created_at: string;
  updated_at: string;
}

/**
 * API Base URL Configuration
 * --------------------------
 * The base URL for the backend API. This can be configured via environment
 * variables for different environments (development, staging, production).
 *
 * Environment Variable: PUBLIC_API_BASE_URL
 * Default: http://localhost:8080 (for local development)
 *
 * Usage:
 * - Set PUBLIC_API_BASE_URL in .env file for custom backend URL
 * - In production, point to your deployed backend server
 *
 * @constant {string}
 */
const API_BASE =
  import.meta.env.PUBLIC_API_BASE_URL ?? "http://localhost:8080";

/**
 * Generic Response Handler
 * ------------------------
 * Processes HTTP responses and handles errors consistently across all API calls.
 *
 * This function:
 * 1. Checks if the response status indicates success (2xx)
 * 2. Attempts to parse error messages from the response body
 * 3. Throws descriptive errors for failed requests
 * 4. Returns parsed JSON data for successful requests
 *
 * Error Handling Strategy:
 * - First tries to extract a custom error message from the response JSON
 * - Falls back to a generic error message with the HTTP status code
 * - Wraps all errors in a standard Error object
 *
 * @template T - The expected type of the response data
 * @param {Response} res - The Fetch API Response object
 * @returns {Promise<T>} - The parsed response data
 * @throws {Error} - If the response status is not OK (2xx)
 *
 * @example
 * const todos = await handleResponse<Todo[]>(response);
 */
async function handleResponse<T>(res: Response): Promise<T> {
  // Check if the response indicates an error (status code outside 200-299)
  if (!res.ok) {
    // Build a default error message with the status code
    let msg = `Request failed with status ${res.status}`;

    try {
      // Attempt to extract a more specific error message from the response body
      // Backend should return { error: "Error message" } for error responses
      const body = await res.json();
      if (body?.error) msg = body.error;
    } catch {
      // If JSON parsing fails, keep the generic status-based message
      // This handles cases where the server returns non-JSON error responses
    }

    // Throw an error to be caught by the calling function
    throw new Error(msg);
  }

  // Parse and return the successful response as JSON
  return res.json();
}

/**
 * Fetch All Todos
 * ---------------
 * Retrieves all todos from the backend API.
 *
 * HTTP Request:
 * - Method: GET
 * - Endpoint: /api/todos
 * - Response: Array of Todo objects
 *
 * @returns {Promise<Todo[]>} - Array of all todos
 * @throws {Error} - If the request fails
 *
 * @example
 * const todos = await fetchTodos();
 * console.log(`Loaded ${todos.length} todos`);
 */
export async function fetchTodos(): Promise<Todo[]> {
  const res = await fetch(`${API_BASE}/api/todos`);
  return handleResponse<Todo[]>(res);
}

/**
 * Create a New Todo
 * -----------------
 * Creates a new todo with the specified title.
 * The backend automatically sets:
 * - id: Auto-generated unique identifier
 * - completed: Initially set to false
 * - created_at: Current timestamp
 * - updated_at: Current timestamp
 *
 * HTTP Request:
 * - Method: POST
 * - Endpoint: /api/todos
 * - Headers: Content-Type: application/json
 * - Body: { title: string }
 * - Response: The created Todo object
 *
 * @param {string} title - The title/content for the new todo
 * @returns {Promise<Todo>} - The newly created todo
 * @throws {Error} - If the request fails
 *
 * @example
 * const newTodo = await createTodo("Buy groceries");
 * console.log(`Created todo with ID: ${newTodo.id}`);
 */
export async function createTodo(title: string): Promise<Todo> {
  const res = await fetch(`${API_BASE}/api/todos`, {
    method: "POST",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify({ title }),
  });
  return handleResponse<Todo>(res);
}

/**
 * Update Payload Interface
 * ------------------------
 * Defines the structure of data that can be updated on a todo.
 *
 * @interface UpdatePayload
 * @property {string} title - The new title for the todo
 * @property {boolean} completed - The new completion status
 */
interface UpdatePayload {
  title: string;
  completed: boolean;
}

/**
 * Update an Existing Todo
 * -----------------------
 * Updates a todo's title and/or completion status.
 * The backend automatically updates the updated_at timestamp.
 *
 * HTTP Request:
 * - Method: PUT
 * - Endpoint: /api/todos/:id
 * - Headers: Content-Type: application/json
 * - Body: { title: string, completed: boolean }
 * - Response: The updated Todo object
 *
 * @param {number} id - The ID of the todo to update
 * @param {UpdatePayload} payload - The update data
 * @returns {Promise<Todo>} - The updated todo
 * @throws {Error} - If the request fails (e.g., todo not found)
 *
 * @example
 * // Toggle completion status
 * const updated = await updateTodo(1, { title: "Buy groceries", completed: true });
 *
 * @example
 * // Update title
 * const updated = await updateTodo(1, { title: "Buy organic groceries", completed: false });
 */
export async function updateTodo(
  id: number,
  payload: UpdatePayload,
): Promise<Todo> {
  const res = await fetch(`${API_BASE}/api/todos/${id}`, {
    method: "PUT",
    headers: { "Content-Type": "application/json" },
    body: JSON.stringify(payload),
  });
  return handleResponse<Todo>(res);
}

/**
 * Delete a Todo
 * -------------
 * Permanently removes a todo from the database.
 * This action cannot be undone.
 *
 * HTTP Request:
 * - Method: DELETE
 * - Endpoint: /api/todos/:id
 * - Response: Empty (204 No Content on success)
 *
 * Note: This function handles both 204 (No Content) and 200 (OK) as success
 * responses, as different backends may return different success codes.
 *
 * @param {number} id - The ID of the todo to delete
 * @returns {Promise<void>} - Resolves when deletion is successful
 * @throws {Error} - If the request fails (e.g., todo not found)
 *
 * @example
 * await deleteTodo(1);
 * console.log("Todo deleted successfully");
 */
export async function deleteTodo(id: number): Promise<void> {
  const res = await fetch(`${API_BASE}/api/todos/${id}`, {
    method: "DELETE",
  });

  // DELETE requests typically return 204 No Content on success
  // We also accept 200 OK as some backends use this instead
  if (!res.ok && res.status !== 204) {
    throw new Error(`Failed to delete todo (${res.status})`);
  }
}
